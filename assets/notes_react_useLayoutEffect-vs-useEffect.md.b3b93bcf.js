import{_ as s,o,c as a,S as n}from"./chunks/framework.1d89e2bb.js";const u=JSON.parse('{"title":"useLayoutEffect 对比 useEffect","description":"","frontmatter":{},"headers":[],"relativePath":"notes/react/useLayoutEffect-vs-useEffect.md","filePath":"notes/react/useLayoutEffect-vs-useEffect.md","lastUpdated":1692683687000}'),e={name:"notes/react/useLayoutEffect-vs-useEffect.md"},l=n(`<h1 id="uselayouteffect-对比-useeffect" tabindex="-1"><code>useLayoutEffect</code> 对比 <code>useEffect</code> <a class="header-anchor" href="#uselayouteffect-对比-useeffect" aria-label="Permalink to &quot;\`useLayoutEffect\` 对比 \`useEffect\`&quot;">​</a></h1><p>在 <code>React</code> 中，有两个用于处理副作用的 <code>Hook</code> ：<code>useEffect</code> 和 <code>useLayoutEffect</code>。它们的主要区别在于执行的时机。</p><ul><li><p><code>useEffect</code> 会在组件渲染完成之后<code>异步执行</code>，也就是在 <code>React</code> 的 <code>commit</code> 阶段之后执行。这意味着在 <code>useEffect</code> 中 进行<strong>布局测量</strong>时，可能会导致页面重新渲染两次，因为<strong>布局测量</strong>可能会改变 <code>DOM</code> 结构。</p></li><li><p><code>useLayoutEffect</code> 会在组件渲染完成之后<code>同步执行</code>，也就是在 <code>React</code> 的 <code>commit</code> 阶段之后，但在浏览器重新绘制屏幕之前，也就是执行时机是在浏览器绘制页面。这意味着在 <code>useLayoutEffect</code> 中进行<strong>布局测量</strong>时，可以确保测量结果能够在浏览器执行绘制之前被使用，从而避免了页面的额外渲染。</p></li></ul><div class="language-tsx"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">useState</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">useEffect</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">useLayoutEffect</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">react</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">count</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">setCount</span><span style="color:#89DDFF;">]</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">useState</span><span style="color:#F07178;">(</span><span style="color:#F78C6C;">0</span><span style="color:#F07178;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">useLayoutEffect</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">current</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">Date</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">now</span><span style="color:#F07178;">()</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">btnEle</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">querySelector</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">HTMLButtonElement</span><span style="color:#89DDFF;">&gt;</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">.test-01</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">btnEle</span><span style="color:#89DDFF;">?.</span><span style="color:#A6ACCD;">innerText</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 如果点击按钮后，这里的结果会是：&quot;add + 1: 1&quot;，</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// Chrome DevTools 里的 element 的 dom 结果也是 &quot;add + 1: 1&quot;。</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">//</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 但是在页面上看还是 &quot;add + 1: 0&quot;，得过了 1 秒后才会更新。</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// 所以 useLayoutEffect 是同步的，会阻塞页面的更新，需要谨慎使用。</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">while</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">Date</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">now</span><span style="color:#F07178;">() </span><span style="color:#89DDFF;">-</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">current</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1000</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{}</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">},</span><span style="color:#F07178;"> [</span><span style="color:#A6ACCD;">count</span><span style="color:#F07178;">])</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> (</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">className</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">test-01</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">onClick</span><span style="color:#89DDFF;">={()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">setCount</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">c</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> c </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">}&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">      add + 1: </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">count</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#F07178;">  )</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><h2 id="为什么布局测量可能会改变-dom-结构" tabindex="-1">为什么<strong>布局测量</strong>可能会改变 <code>DOM</code> 结构？ <a class="header-anchor" href="#为什么布局测量可能会改变-dom-结构" aria-label="Permalink to &quot;为什么**布局测量**可能会改变 \`DOM\` 结构？&quot;">​</a></h2><p><strong>布局测量</strong>可能会改变 <code>DOM</code> 结构的原因是，<strong>布局测量</strong>通常需要获取元素的尺寸和位置信息，以便进行后续的布局计算或者样式调整。在获取这些信息的过程中，浏览器可能会触发重排（<code>reflow</code>）操作，这会重新计算元素的布局，并且可能会导致 <code>DOM</code> 结构的改变。当浏览器执行布局操作时，它需要考虑到元素的大小、位置、边距、边框、内边距等因素，以及其他相关元素的布局信息。</p><p>因此，如果<strong>布局测量</strong>的结果会影响到元素的布局属性，例如宽度、高度、位置等，那么浏览器可能会重新计算元素的布局，并且可能会导致 <code>DOM</code> 结构的改变。</p><p>举个例子，假设在<strong>布局测量</strong>过程中，我们获取了一个元素的宽度，并根据它的宽度计算了另一个元素的位置。</p><p>这个计算过程可能会触发浏览器的重排（<code>reflow</code>）操作，导致元素的位置发生变化，从而改变了 <code>DOM</code> 结构。因此，在进行<strong>布局测量</strong>时，需要注意可能引起 <code>DOM</code> 结构改变的情况，并谨慎处理，以避免不必要的重排（<code>reflow</code>）操作。</p><h2 id="为什么在浏览器执行绘制之前执行" tabindex="-1">为什么在浏览器执行绘制之前执行？ <a class="header-anchor" href="#为什么在浏览器执行绘制之前执行" aria-label="Permalink to &quot;为什么在浏览器执行绘制之前执行？&quot;">​</a></h2><p>在浏览器渲染页面时，渲染过程通常分为多个阶段，其中包括布局（<code>layout</code>）、绘制（<code>paint</code>）和合成（<code>composite</code>）等步骤。在这个过程中，浏览器会根据 DOM 结构和样式信息计算元素的位置、大小和样式，并最终将页面绘制到屏幕上。</p><p><code>useLayoutEffect</code> <code>Hook</code> 会在浏览器执行绘制之前同步执行。这意味着在 <code>useLayoutEffect</code> 中进行的 <code>DOM</code> 操作或者布局测量，会在浏览器进行实际绘制之前生效。</p><p>换句话说，当 <code>useLayoutEffect</code> 中的代码执行完毕后，浏览器会根据最新的 <code>DOM</code> 结构和样式信息进行布局计算，并准备好将页面绘制到屏幕上。因此，在 <code>useLayoutEffect</code> 中进行的DOM操作或者布局测量可以确保在浏览器执行绘制之前生效，从而避免了页面的额外渲染。</p><p>需要注意的是，由于 <code>useLayoutEffect</code> 是同步执行的，如果在其中进行复杂的操作或者阻塞代码的执行，可能会导致页面的卡顿或者性能问题。因此，在使用 <code>useLayoutEffect</code> 时，应该确保其中的操作是必要且高效的，以避免影响页面的性能和用户体验。</p><ul><li>参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work" target="_blank" rel="noreferrer">MDN：渲染页面：浏览器的工作原理</a></li><li>参考 <a href="https://zh-hans.react.dev/reference/react/useEffect" target="_blank" rel="noreferrer">React Doc：useEffect</a></li><li>参考 <a href="https://zh-hans.react.dev/reference/react/useLayoutEffect" target="_blank" rel="noreferrer">React Doc：useLayoutEffect</a></li></ul>`,15),t=[l];function p(c,r,y,F,D,d){return o(),a("div",null,t)}const i=s(e,[["render",p]]);export{u as __pageData,i as default};
