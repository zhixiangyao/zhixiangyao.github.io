import{_ as o,c as r,o as t,al as c}from"./chunks/framework.QMTCfPyU.js";const F=JSON.parse('{"title":"React Fiber 的概念与工作原理","description":"","frontmatter":{},"headers":[],"relativePath":"notes/react/introduces-fiber-concept.md","filePath":"notes/react/introduces-fiber-concept.md","lastUpdated":1729003399000}'),i={name:"notes/react/introduces-fiber-concept.md"};function d(a,e,n,s,l,g){return t(),r("div",null,[...e[0]||(e[0]=[c('<h1 id="react-fiber-的概念与工作原理" tabindex="-1"><code>React Fiber</code> 的概念与工作原理 <a class="header-anchor" href="#react-fiber-的概念与工作原理" aria-label="Permalink to “React Fiber 的概念与工作原理”">​</a></h1><p>在 <code>React</code> 中, 每个<strong>函数组件的实例</strong>并不直接是一个 <strong><code>Fiber</code></strong>, 但每个组件确实都有一个与之对应的 <strong><code>Fiber</code> 节点</strong>. <code>Fiber</code> 是 <code>React</code> 用来管理和调度组件渲染的内部机制. <code>React Fiber</code> 引入了一种全新的架构, 帮助解决了之前同步渲染带来的性能问题. 让我们详细说明 <code>Fiber</code> 的历史背景、数据结构及工作原理.</p><h2 id="react-fiber-的历史背景与产生原因" tabindex="-1"><strong><code>React Fiber</code> 的历史背景与产生原因</strong> <a class="header-anchor" href="#react-fiber-的历史背景与产生原因" aria-label="Permalink to “React Fiber 的历史背景与产生原因”">​</a></h2><p>在 <code>React Fiber</code> 出现之前, <code>React</code> 使用的是同步渲染模型, 这意味着每次更新时, <code>React</code> 会一次性从头到尾完成整个组件树的渲染. 如果组件树庞大或者渲染操作复杂, 这会导致 UI 卡顿, 用户体验变差.</p><p><code>React Fiber</code> 产生的主要原因是为了解决以下问题：</p><ol><li><strong>性能问题</strong>：同步渲染无法分割渲染任务, 导致 <code>React</code> 的 UI 响应速度下降, 尤其是在复杂场景下.</li><li><strong>响应性</strong>：<code>React Fiber</code> 通过引入增量渲染, 让渲染过程可以分成小任务, 在任务之间可以让出控制权给浏览器, 处理更高优先级的任务 (如用户输入) , 从而提升应用的响应速度.</li></ol><h2 id="什么是-fiber" tabindex="-1"><strong>什么是 Fiber?</strong> <a class="header-anchor" href="#什么是-fiber" aria-label="Permalink to “什么是 Fiber?”">​</a></h2><p><code>Fiber</code> 是 <code>React 16</code> 引入的一种基于<strong>链表</strong>的数据结构, 用来表示组件树中的每个组件. 它使 <code>React</code> 能够将渲染工作分解为多个小任务, 并允许在执行这些任务的过程中暂停、继续或丢弃它们. <code>Fiber</code> 实现了<strong>并发渲染</strong>和<strong>任务优先级调度</strong>, 从而提高了渲染的灵活性和性能.</p><h2 id="函数组件与-fiber-的关系" tabindex="-1"><strong>函数组件与 <code>Fiber</code> 的关系</strong> <a class="header-anchor" href="#函数组件与-fiber-的关系" aria-label="Permalink to “函数组件与 Fiber 的关系”">​</a></h2><p>在 <code>React</code> 的渲染流程中, 每个组件 (无论是函数组件还是类组件) 都会有一个对应的 <code>Fiber</code> 节点. <code>Fiber</code> 节点记录了该组件的状态、<strong>DOM</strong> 信息以及与组件渲染相关的其他元数据.</p><ul><li><strong>函数组件</strong>本质上是一个普通的 <code>JavaScript</code> 函数, 没有实例化 this 对象. 因此, <code>React</code> 通过 <code>Fiber</code> 节点来存储和管理与函数组件相关的状态和生命周期.</li><li>每个函数组件在每次渲染时, <code>React</code> 都会创建或更新与之对应的 <code>Fiber</code> 节点, <code>Fiber</code> 节点是 <code>React</code> 内部调度渲染的关键部分.</li></ul><h2 id="fiber-节点中的关键信息" tabindex="-1"><strong><code>Fiber</code> 节点中的关键信息</strong> <a class="header-anchor" href="#fiber-节点中的关键信息" aria-label="Permalink to “Fiber 节点中的关键信息”">​</a></h2><p>每个 <code>Fiber</code> 节点代表一个组件, 并包含以下关键信息：</p><ul><li><strong>tag</strong>: 表示 <code>Fiber</code> 组件的类型，例如 <strong>Function</strong> 组件和 <strong>class</strong> 组件。</li><li><strong>key</strong>: 组件的 <code>key</code> 属性，用于在 diff 算法中帮助识别组件的唯一性。</li><li><strong>elementType</strong>: 代表组件的类型，特定情况下（如被 <code>React.memo</code> 包裹时）可能与 <code>type</code> 不同。</li><li><strong>type</strong>: 指向组件的类型，对于函数组件是函数本身，对于类组件是类，对于 <strong>DOM</strong> 节点是其 tagName。</li><li><strong>stateNode</strong>: <code>Fiber</code> 对应的实际 <strong>DOM</strong> 节点的引用。</li><li><strong>return</strong>: 指向父 <code>Fiber</code> 节点，形成 <code>Fiber</code> 树的链接关系。</li><li><strong>child</strong>: 指向子 <code>Fiber</code> 节点，维护组件树的层级结构。</li><li><strong>sibling</strong>: 指向同一层级的下一个兄弟 <code>Fiber</code> 节点。</li><li><strong>index</strong>: 当前节点在兄弟节点中的位置索引。</li><li><strong>pendingProps</strong>: 当前组件的属性，表示本次渲染的最新属性。</li><li><strong>memoizedProps</strong>: 指向最近一次使用的 props，用于比较和更新。</li><li><strong>updateQueue</strong>: 保存需要处理的更新信息的队列。</li><li><strong>memoizedState</strong>: 组件的状态，用于保存当前状态值。</li><li><strong>dependencies</strong>: 指向依赖于该组件的其他组件或数据。</li><li><strong>mode</strong>: 表示组件运行的模式（并发模式或遗留模式），影响组件的更新方式。</li><li><strong>flags</strong>: 当前组件的标记位，表示需要执行的操作（如更新、删除等）。</li><li><strong>subtreeFlags</strong>: 当前组件子树的标记位，用于跟踪子组件的状态。</li><li><strong>deletions</strong>: 保存需要删除的 <code>Fiber</code> 对象链表，以便在提交时处理。</li><li><strong>lanes</strong>: 当前组件的调度优先级，用于调度更新任务。</li><li><strong>childLanes</strong>: 子组件的优先级，表示在当前 <code>Fiber</code> 节点下的子组件的优先级。</li><li><strong>alternate</strong>: 指向该 <code>Fiber</code> 在另一次更新时对应的 <code>Fiber</code>，允许 React 在更新过程中重用 <code>Fiber</code> 结构。</li></ul><h2 id="fiber-如何管理函数组件" tabindex="-1"><strong><code>Fiber</code> 如何管理函数组件</strong> <a class="header-anchor" href="#fiber-如何管理函数组件" aria-label="Permalink to “Fiber 如何管理函数组件”">​</a></h2><p>函数组件没有类组件中的实例, 因此 <code>React</code> 通过 <code>Fiber</code> 来管理函数组件的状态、Hooks 等信息：</p><ul><li><strong>useState 与 Fiber</strong>：useState 会将状态信息记录在与该组件对应的 <code>Fiber</code> 节点中, 每次状态更新时, <code>React</code> 会更新该节点.</li><li><strong>useEffect 与 Fiber</strong>：useEffect 的副作用函数同样会被绑定到当前的 <code>Fiber</code> 节点上, 等待适当时机执行.</li></ul><h2 id="react-fiber-的工作原理" tabindex="-1"><strong><code>React Fiber</code> 的工作原理</strong> <a class="header-anchor" href="#react-fiber-的工作原理" aria-label="Permalink to “React Fiber 的工作原理”">​</a></h2><p>React 的渲染分为两个阶段：<strong>协调阶段 (Render Phase)</strong> 和 <strong>提交阶段 (Commit Phase)</strong>.</p><ol><li><strong>协调阶段 (Render Phase)</strong><ul><li>在这个阶段, <code>React</code> 会遍历 <code>Fiber</code> 树, 比较新旧虚拟 <strong>DOM</strong>, 创建新的 <code>Fiber</code> 节点, 并标记需要更新的部分. 这个阶段是可中断的, <code>React</code> 可以在任务之间暂停, 处理更高优先级的任务.</li></ul></li><li><strong>提交阶段 (Commit Phase)</strong><ul><li>提交阶段是不可中断的, <code>React</code> 会将协调阶段收集到的更改应用到真实 <strong>DOM</strong> 上, 并执行 useLayoutEffect 等同步副作用.</li></ul></li></ol><h2 id="react-fiber-的关键特性" tabindex="-1"><strong><code>React Fiber</code> 的关键特性</strong> <a class="header-anchor" href="#react-fiber-的关键特性" aria-label="Permalink to “React Fiber 的关键特性”">​</a></h2><ul><li><strong>任务优先级调度</strong>：<code>React Fiber</code> 根据任务的优先级, 灵活安排更新任务, 确保更紧急的任务 (如用户输入) 优先处理.</li><li><strong>异步渲染</strong>：通过将渲染工作分割成更小的任务, <code>React</code> 可以在多个帧中完成渲染, 避免主线程长时间被占用.</li><li><strong>时间分片</strong>：<code>React Fiber</code> 可以将大任务拆分为时间片, 在每个时间片内执行一部分任务, 使得 UI 渲染更流畅.</li></ul><h2 id="总结" tabindex="-1"><strong>总结</strong> <a class="header-anchor" href="#总结" aria-label="Permalink to “总结”">​</a></h2><ul><li>每个 <code>React</code> 函数组件与一个 <code>Fiber</code> 节点密切关联, 该节点用于调度和管理组件的渲染过程.</li><li><code>Fiber</code> 是 <code>React</code> 内部的核心数据结构, 追踪组件的状态、属性、<strong>DOM</strong> 引用等信息.</li><li><code>React Fiber</code> 通过分割渲染任务、调度任务优先级, 优化了复杂 UI 场景下的性能和响应速度.</li></ul><p><code>React Fiber</code> 的引入大幅提升了 <code>React</code> 在复杂应用中的性能表现, 同时为实现并发渲染奠定了基础.</p>',25)])])}const h=o(i,[["render",d]]);export{F as __pageData,h as default};
