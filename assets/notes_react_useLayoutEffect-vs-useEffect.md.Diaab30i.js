import{_ as i,c as a,o as e,ak as t}from"./chunks/framework.BXZ7Tjj5.js";const r=JSON.parse('{"title":"useLayoutEffect 对比 useEffect","description":"","frontmatter":{},"headers":[],"relativePath":"notes/react/useLayoutEffect-vs-useEffect.md","filePath":"notes/react/useLayoutEffect-vs-useEffect.md","lastUpdated":1692683687000}'),n={name:"notes/react/useLayoutEffect-vs-useEffect.md"};function l(h,s,p,k,o,d){return e(),a("div",null,s[0]||(s[0]=[t(`<h1 id="uselayouteffect-对比-useeffect" tabindex="-1"><code>useLayoutEffect</code> 对比 <code>useEffect</code> <a class="header-anchor" href="#uselayouteffect-对比-useeffect" aria-label="Permalink to &quot;\`useLayoutEffect\` 对比 \`useEffect\`&quot;">​</a></h1><p>在 <code>React</code> 中，有两个用于处理副作用的 <code>Hook</code> ：<code>useEffect</code> 和 <code>useLayoutEffect</code>。它们的主要区别在于执行的时机。</p><ul><li><p><code>useEffect</code> 会在组件渲染完成之后<code>异步执行</code>，也就是在 <code>React</code> 的 <code>commit</code> 阶段之后执行。这意味着在 <code>useEffect</code> 中 进行<strong>布局测量</strong>时，可能会导致页面重新渲染两次，因为<strong>布局测量</strong>可能会改变 <code>DOM</code> 结构。</p></li><li><p><code>useLayoutEffect</code> 会在组件渲染完成之后<code>同步执行</code>，也就是在 <code>React</code> 的 <code>commit</code> 阶段之后，但在浏览器重新绘制屏幕之前，也就是执行时机是在浏览器绘制页面。这意味着在 <code>useLayoutEffect</code> 中进行<strong>布局测量</strong>时，可以确保测量结果能够在浏览器执行绘制之前被使用，从而避免了页面的额外渲染。</p></li></ul><div class="language-tsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { useState, useEffect, useLayoutEffect } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;react&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">count</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  useLayoutEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> current</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> btnEle</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">querySelector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">HTMLButtonElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;.test-01&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(btnEle?.innerText)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 如果点击按钮后，这里的结果会是：&quot;add + 1: 1&quot;，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // Chrome DevTools 里的 element 的 dom 结果也是 &quot;add + 1: 1&quot;。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 但是在页面上看还是 &quot;add + 1: 0&quot;，得过了 1 秒后才会更新。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 所以 useLayoutEffect 是同步的，会阻塞页面的更新，需要谨慎使用。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }, [count])</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> className</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;test-01&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onClick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setCount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">c</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)}&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      add + 1: {count}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="为什么布局测量可能会改变-dom-结构" tabindex="-1">为什么<strong>布局测量</strong>可能会改变 <code>DOM</code> 结构？ <a class="header-anchor" href="#为什么布局测量可能会改变-dom-结构" aria-label="Permalink to &quot;为什么**布局测量**可能会改变 \`DOM\` 结构？&quot;">​</a></h2><p><strong>布局测量</strong>可能会改变 <code>DOM</code> 结构的原因是，<strong>布局测量</strong>通常需要获取元素的尺寸和位置信息，以便进行后续的布局计算或者样式调整。在获取这些信息的过程中，浏览器可能会触发重排（<code>reflow</code>）操作，这会重新计算元素的布局，并且可能会导致 <code>DOM</code> 结构的改变。当浏览器执行布局操作时，它需要考虑到元素的大小、位置、边距、边框、内边距等因素，以及其他相关元素的布局信息。</p><p>因此，如果<strong>布局测量</strong>的结果会影响到元素的布局属性，例如宽度、高度、位置等，那么浏览器可能会重新计算元素的布局，并且可能会导致 <code>DOM</code> 结构的改变。</p><p>举个例子，假设在<strong>布局测量</strong>过程中，我们获取了一个元素的宽度，并根据它的宽度计算了另一个元素的位置。</p><p>这个计算过程可能会触发浏览器的重排（<code>reflow</code>）操作，导致元素的位置发生变化，从而改变了 <code>DOM</code> 结构。因此，在进行<strong>布局测量</strong>时，需要注意可能引起 <code>DOM</code> 结构改变的情况，并谨慎处理，以避免不必要的重排（<code>reflow</code>）操作。</p><h2 id="为什么在浏览器执行绘制之前执行" tabindex="-1">为什么在浏览器执行绘制之前执行？ <a class="header-anchor" href="#为什么在浏览器执行绘制之前执行" aria-label="Permalink to &quot;为什么在浏览器执行绘制之前执行？&quot;">​</a></h2><p>在浏览器渲染页面时，渲染过程通常分为多个阶段，其中包括布局（<code>layout</code>）、绘制（<code>paint</code>）和合成（<code>composite</code>）等步骤。在这个过程中，浏览器会根据 DOM 结构和样式信息计算元素的位置、大小和样式，并最终将页面绘制到屏幕上。</p><p><code>useLayoutEffect</code> <code>Hook</code> 会在浏览器执行绘制之前同步执行。这意味着在 <code>useLayoutEffect</code> 中进行的 <code>DOM</code> 操作或者布局测量，会在浏览器进行实际绘制之前生效。</p><p>换句话说，当 <code>useLayoutEffect</code> 中的代码执行完毕后，浏览器会根据最新的 <code>DOM</code> 结构和样式信息进行布局计算，并准备好将页面绘制到屏幕上。因此，在 <code>useLayoutEffect</code> 中进行的DOM操作或者布局测量可以确保在浏览器执行绘制之前生效，从而避免了页面的额外渲染。</p><p>需要注意的是，由于 <code>useLayoutEffect</code> 是同步执行的，如果在其中进行复杂的操作或者阻塞代码的执行，可能会导致页面的卡顿或者性能问题。因此，在使用 <code>useLayoutEffect</code> 时，应该确保其中的操作是必要且高效的，以避免影响页面的性能和用户体验。</p><ul><li>参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work" target="_blank" rel="noreferrer">MDN：渲染页面：浏览器的工作原理</a></li><li>参考 <a href="https://zh-hans.react.dev/reference/react/useEffect" target="_blank" rel="noreferrer">React Doc：useEffect</a></li><li>参考 <a href="https://zh-hans.react.dev/reference/react/useLayoutEffect" target="_blank" rel="noreferrer">React Doc：useLayoutEffect</a></li></ul>`,15)]))}const E=i(n,[["render",l]]);export{r as __pageData,E as default};
