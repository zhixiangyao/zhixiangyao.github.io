import{_ as s,c as i,o as a,a8 as e}from"./chunks/framework.DNprFXYc.js";const u=JSON.parse('{"title":"JS 中的闭包是什么","description":"","frontmatter":{},"headers":[],"relativePath":"notes/javascript/what-is-the-closure-in-js.md","filePath":"notes/javascript/what-is-the-closure-in-js.md","lastUpdated":1693915307000}'),n={name:"notes/javascript/what-is-the-closure-in-js.md"},t=e(`<h1 id="js-中的闭包是什么" tabindex="-1">JS 中的闭包是什么 <a class="header-anchor" href="#js-中的闭包是什么" aria-label="Permalink to &quot;JS 中的闭包是什么&quot;">​</a></h1><p>在 <code>JavaScript</code> 中， <code>闭包</code> 是指在函数内部创建的函数，并且可以访问到外部函数的变量。简单来说， <code>闭包</code> 是由函数以及创建该函数的词法环境组合而成的。</p><p><code>闭包</code> 可以理解为一个函数和该函数所在的词法环境的组合体，词法环境是指变量和函数的定义时所处的环境。 <code>闭包</code> 可以访问外部函数的变量，即使外部函数已经执行完毕，这是因为 <code>闭包</code> 保留了对外部函数词法环境的引用。</p><p><code>闭包</code> 的一个常见应用是在函数内部创建私有变量。通过使用 <code>闭包</code> ，可以在函数内部定义变量，并且只能通过内部函数来访问和修改这些变量，从而实现了私有变量的效果。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> outerFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> outerVariable </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;Hello&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> innerFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(outerVariable)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> innerFunction</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> closure </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> outerFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">closure</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 &#39;Hello&#39;</span></span></code></pre></div><p>在上面的示例中，<code>innerFunction</code> 是一个闭包，它可以访问到外部函数 <code>outerFunction</code> 中的 <code>outerVariable</code> 变量。当调用 <code>outerFunction</code> 时，它返回了 <code>innerFunction</code>，并将其赋值给变量 <code>closure</code>。当调用 <code>closure</code> 时，它仍然可以访问到 <code>outerVariable</code> 的值，并输出结果为 <code>&#39;Hello&#39;</code>。这是因为闭包保留了对外部函数词法环境的引用，即使外部函数已经执行完毕。</p><h2 id="场景" tabindex="-1">场景 <a class="header-anchor" href="#场景" aria-label="Permalink to &quot;场景&quot;">​</a></h2><ul><li><p><strong>实现私有变量和私有函数</strong>：通过使用 <code>闭包</code> ，可以在函数内部创建变量和函数，并且只能通过内部函数来访问和修改这些变量，从而实现了私有变量和私有函数的效果。这样可以避免全局命名空间的污染和变量的意外修改。</p></li><li><p><strong>保存函数的状态</strong>：<code>闭包</code> 可以保存函数的状态，即使函数已经执行完毕。通过在 <code>闭包</code> 中保存变量的引用，可以在函数执行后继续访问和修改这些变量。这对于一些需要记住状态的场景非常有用，例如计数器、缓存等。</p></li><li><p><strong>创建函数工厂</strong>：<code>闭包</code> 可以用于创建函数工厂，即根据不同的参数返回不同的函数。通过在 <code>闭包</code> 中保存参数的引用，可以在返回的函数中使用这些参数，从而实现了函数的定制化。</p></li><li><p><strong>实现模块化</strong>：通过使用 <code>闭包</code> ，可以将相关的变量和函数封装在一个函数内部，从而实现模块化的效果。这样可以减少全局变量的使用，提高代码的可维护性和可复用性。</p></li></ul><p>需要注意的是，<code>闭包</code> 在使用不当的情况下可能会导致内存泄漏，因为 <code>闭包</code> 会持有对外部变量的引用，导致这些变量无法被垃圾回收。因此，在使用 <code>闭包</code> 时需要注意内存管理，并及时释放不再需要的 <code>闭包</code> 。</p><div class="warning custom-block"><p class="custom-block-title">注意点</p><p>在现代的 <code>JavaScript</code> 中，<code>闭包</code> 的很多场景已经消失了，比如模块化。</p></div>`,10),o=[t];function l(c,p,d,h,r,k){return a(),i("div",null,o)}const g=s(n,[["render",l]]);export{u as __pageData,g as default};
